<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emacs-Style Editor</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "SF Mono", "Fira Code", "Menlo", "Consolas", monospace;
    }

    body {
      margin: 0;
      background: #0f1115;
      color: #f1f4f8;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 16px 20px;
      border-bottom: 1px solid #242b38;
      background: #161a22;
    }

    header h1 {
      margin: 0 0 6px;
      font-size: 18px;
      font-weight: 600;
    }

    header p {
      margin: 0;
      font-size: 13px;
      color: #9aa4b2;
      max-width: 720px;
      line-height: 1.5;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      box-sizing: border-box;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .modifier-button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 10px;
      padding: 10px 14px;
      font-size: 14px;
      font-weight: 600;
      background: #243049;
      color: #f0f4ff;
      cursor: pointer;
      min-width: 80px;
      transition: transform 0.1s ease, border-color 0.15s ease, background 0.15s ease;
    }

    .modifier-button:active {
      transform: translateY(1px);
    }

    .modifier-button.is-active {
      border-color: #3d6cff;
      background: #2f3f60;
      box-shadow: 0 0 0 2px rgba(61, 108, 255, 0.2);
    }

    .modifier-button.is-latched {
      border-color: #66d19e;
      background: #1f3d2b;
      color: #e6ffef;
      box-shadow: 0 0 0 2px rgba(102, 209, 158, 0.3);
    }

    .modifier-hint {
      font-size: 12px;
      color: #9aa4b2;
    }

    textarea {
      width: 100%;
      flex: 1;
      resize: none;
      padding: 16px;
      font-size: 15px;
      line-height: 1.6;
      border-radius: 12px;
      border: 1px solid #2d3445;
      background: #0b0d12;
      color: #f5f7fb;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }

    textarea:focus {
      outline: 2px solid #3d6cff;
      border-color: #3d6cff;
    }

    .command-buffer {
      display: none;
      flex-direction: column;
      gap: 8px;
    }

    .command-buffer.is-active {
      display: flex;
    }

    .command-buffer label {
      font-size: 12px;
      color: #9aa4b2;
    }

    .command-buffer textarea {
      min-height: 48px;
      font-size: 14px;
      background: #131826;
    }

    .cheatsheet {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px 16px;
      font-size: 12px;
      color: #b5bfcd;
    }

    .cheatsheet span {
      color: #f1f4f8;
      font-weight: 600;
    }

    @media (max-width: 600px) {
      main {
        padding: 16px;
      }

      .modifier-button {
        min-width: 70px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Emacs-Style Editor</h1>
    <p>
      Use the on-screen C (Ctrl) and M (Meta) buttons to trigger Emacs-style commands.
      Tap once for a single command, or double-click to latch a modifier. Typing without
      modifiers inserts characters normally.
    </p>
  </header>

  <main>
    <div class="toolbar" aria-label="Modifier toolbar">
      <button type="button" class="modifier-button" data-modifier="ctrl" aria-pressed="false">
        C
      </button>
      <button type="button" class="modifier-button" data-modifier="meta" aria-pressed="false">
        M
      </button>
      <div class="modifier-hint">
        Double-click to latch • Click to toggle once
      </div>
    </div>

    <div class="command-buffer" id="command-buffer" aria-hidden="true">
      <label for="command-input">Command input (C/M active)</label>
      <textarea
        id="command-input"
        aria-label="Command input"
        spellcheck="false"
        placeholder="Press a command key…"
      ></textarea>
    </div>

    <textarea
      id="editor"
      aria-label="Emacs-style text editor"
      spellcheck="false"
      placeholder="Start typing here..."
    ></textarea>

    <div class="cheatsheet" aria-label="Emacs key binding cheatsheet">
      <div><span>C-a</span> line start</div>
      <div><span>C-e</span> line end</div>
      <div><span>C-f</span> forward char</div>
      <div><span>C-b</span> backward char</div>
      <div><span>C-n</span> next line</div>
      <div><span>C-p</span> previous line</div>
      <div><span>C-d</span> delete char</div>
      <div><span>C-k</span> kill to line end</div>
      <div><span>C-y</span> yank (paste)</div>
      <div><span>C-Space</span> selection mode</div>
      <div><span>M-f</span> forward word</div>
      <div><span>M-b</span> backward word</div>
      <div><span>M-&lt;</span> buffer start</div>
      <div><span>M-&gt;</span> buffer end</div>
    </div>
  </main>

  <script>
    const editor = document.getElementById("editor");
    const modifierButtons = document.querySelectorAll("[data-modifier]");
    const commandBuffer = document.getElementById("command-buffer");
    const commandInput = document.getElementById("command-input");

    const modifierState = {
      ctrl: { active: false, latched: false, button: null },
      meta: { active: false, latched: false, button: null }
    };

    let killBuffer = "";
    const selectionState = { active: false, anchor: 0 };

    const getLineBounds = (text, index) => {
      const start = text.lastIndexOf("\n", index - 1) + 1;
      const endBreak = text.indexOf("\n", index);
      const end = endBreak === -1 ? text.length : endBreak;
      return { start, end };
    };

    const getColumn = (text, index) => index - (text.lastIndexOf("\n", index - 1) + 1);

    const updateButton = (state) => {
      const { button, active, latched } = state;
      if (!button) return;
      button.classList.toggle("is-active", active && !latched);
      button.classList.toggle("is-latched", latched);
      button.setAttribute("aria-pressed", String(active || latched));
    };

    const setModifierState = (key, { active, latched }) => {
      modifierState[key].active = active;
      modifierState[key].latched = latched;
      updateButton(modifierState[key]);
    };

    const resetModifierIfNeeded = (key) => {
      if (modifierState[key].active && !modifierState[key].latched) {
        setModifierState(key, { active: false, latched: false });
      }
    };

    const moveCursor = (pos) => {
      editor.setSelectionRange(pos, pos);
      editor.focus();
    };

    const applySelection = (pos) => {
      if (selectionState.active) {
        editor.setSelectionRange(selectionState.anchor, pos);
        editor.focus();
        return;
      }
      moveCursor(pos);
    };

    const exitSelectionMode = () => {
      if (!selectionState.active) return;
      selectionState.active = false;
      const pos = editor.selectionEnd;
      editor.setSelectionRange(pos, pos);
    };

    const moveVertical = (direction) => {
      const text = editor.value;
      const pos = editor.selectionStart;
      const { start: lineStart } = getLineBounds(text, pos);
      const column = getColumn(text, pos);
      const targetLineIndex = direction === "up"
        ? text.lastIndexOf("\n", lineStart - 2)
        : text.indexOf("\n", lineStart);

      if (direction === "up" && targetLineIndex === -1) {
        applySelection(0);
        return;
      }

      if (direction === "down" && targetLineIndex === -1) {
        applySelection(text.length);
        return;
      }

      const targetLineStart = direction === "up"
        ? (text.lastIndexOf("\n", targetLineIndex - 1) + 1)
        : targetLineIndex + 1;
      const targetLineEnd = getLineBounds(text, targetLineStart).end;
      const nextPos = Math.min(targetLineStart + column, targetLineEnd);
      applySelection(nextPos);
    };

    const moveWord = (direction) => {
      const text = editor.value;
      const pos = editor.selectionStart;

      if (direction === "forward") {
        const after = text.slice(pos);
        const match = after.match(/\w+|\W+/);
        if (!match) {
          applySelection(text.length);
          return;
        }
        applySelection(pos + match[0].length);
      } else {
        const before = text.slice(0, pos);
        const match = before.match(/(\w+|\W+)(?=\w*\W*$)/);
        if (!match) {
          applySelection(0);
          return;
        }
        applySelection(before.length - match[0].length);
      }
    };

    const deleteCharForward = () => {
      const { selectionStart, selectionEnd, value } = editor;
      if (selectionStart !== selectionEnd) {
        editor.value = value.slice(0, selectionStart) + value.slice(selectionEnd);
        exitSelectionMode();
        moveCursor(selectionStart);
        return;
      }
      if (selectionStart < value.length) {
        editor.value = value.slice(0, selectionStart) + value.slice(selectionStart + 1);
        moveCursor(selectionStart);
      }
    };

    const killToEndOfLine = () => {
      const { selectionStart, value } = editor;
      const { end } = getLineBounds(value, selectionStart);
      killBuffer = value.slice(selectionStart, end);
      editor.value = value.slice(0, selectionStart) + value.slice(end);
      exitSelectionMode();
      moveCursor(selectionStart);
    };

    const yank = () => {
      if (!killBuffer) return;
      const { selectionStart, selectionEnd, value } = editor;
      editor.value = value.slice(0, selectionStart) + killBuffer + value.slice(selectionEnd);
      exitSelectionMode();
      moveCursor(selectionStart + killBuffer.length);
    };

    const toggleSelectionMode = () => {
      if (selectionState.active) {
        exitSelectionMode();
        return;
      }
      selectionState.active = true;
      selectionState.anchor = editor.selectionStart;
      editor.setSelectionRange(selectionState.anchor, selectionState.anchor);
    };

    const executeCommand = (command) => {
      switch (command) {
        case "line-start":
          applySelection(getLineBounds(editor.value, editor.selectionStart).start);
          break;
        case "line-end":
          applySelection(getLineBounds(editor.value, editor.selectionStart).end);
          break;
        case "forward-char":
          applySelection(Math.min(editor.value.length, editor.selectionStart + 1));
          break;
        case "backward-char":
          applySelection(Math.max(0, editor.selectionStart - 1));
          break;
        case "next-line":
          moveVertical("down");
          break;
        case "previous-line":
          moveVertical("up");
          break;
        case "delete-char":
          deleteCharForward();
          break;
        case "kill-line":
          killToEndOfLine();
          break;
        case "yank":
          yank();
          break;
        case "forward-word":
          moveWord("forward");
          break;
        case "backward-word":
          moveWord("backward");
          break;
        case "buffer-start":
          applySelection(0);
          break;
        case "buffer-end":
          applySelection(editor.value.length);
          break;
        case "selection-mode":
          toggleSelectionMode();
          break;
        default:
          return false;
      }
      return true;
    };

    const keyBindings = {
      ctrl: {
        a: "line-start",
        e: "line-end",
        f: "forward-char",
        b: "backward-char",
        n: "next-line",
        p: "previous-line",
        d: "delete-char",
        k: "kill-line",
        y: "yank",
        space: "selection-mode"
      },
      meta: {
        f: "forward-word",
        b: "backward-word",
        "<": "buffer-start",
        ">": "buffer-end"
      }
    };

    const isAnyModifierActive = () => modifierState.ctrl.active || modifierState.meta.active;

    const setCommandBufferActive = (active) => {
      commandBuffer.classList.toggle("is-active", active);
      commandBuffer.setAttribute("aria-hidden", String(!active));
      if (active) {
        commandInput.value = "";
        commandInput.focus();
      }
    };

    const handleModifierToggle = (key, latched) => {
      if (latched) {
        setModifierState(key, { active: true, latched: true });
        setCommandBufferActive(true);
        return;
      }

      if (modifierState[key].latched) {
        setModifierState(key, { active: false, latched: false });
        setCommandBufferActive(isAnyModifierActive());
        return;
      }

      setModifierState(key, { active: !modifierState[key].active, latched: false });
      setCommandBufferActive(isAnyModifierActive());
    };

    modifierButtons.forEach((button) => {
      const key = button.dataset.modifier;
      modifierState[key].button = button;

      button.addEventListener("click", () => handleModifierToggle(key, false));
      button.addEventListener("dblclick", () => handleModifierToggle(key, true));
    });

    const getBindingKey = (event) => {
      if (event.key === " " || event.key === "Spacebar" || event.key === "Space") {
        return "space";
      }
      return event.key.length === 1 ? event.key.toLowerCase() : event.key;
    };

    const finalizeCommand = () => {
      const shouldStayActive = modifierState.ctrl.latched || modifierState.meta.latched;
      if (!shouldStayActive) {
        setModifierState("ctrl", { active: false, latched: false });
        setModifierState("meta", { active: false, latched: false });
        setCommandBufferActive(false);
        editor.focus();
      } else {
        commandInput.value = "";
        commandInput.focus();
      }
    };

    editor.addEventListener("keydown", (event) => {
      if (modifierState.ctrl.active || modifierState.meta.active) {
        event.preventDefault();
        setCommandBufferActive(true);
      }
    });

    editor.addEventListener("input", () => {
      exitSelectionMode();
    });

    commandInput.addEventListener("keydown", (event) => {
      const ctrlActive = modifierState.ctrl.active || event.ctrlKey;
      const metaActive = modifierState.meta.active || event.metaKey;
      if (!ctrlActive && !metaActive) {
        return;
      }

      const key = getBindingKey(event);
      const bindings = ctrlActive ? keyBindings.ctrl : keyBindings.meta;
      const command = bindings[key];

      if (!command) {
        if (ctrlActive) resetModifierIfNeeded("ctrl");
        if (metaActive) resetModifierIfNeeded("meta");
        setCommandBufferActive(false);
        editor.focus();
        return;
      }

      event.preventDefault();
      executeCommand(command);
      commandInput.value = "";

      if (ctrlActive && modifierState.ctrl.active && !modifierState.ctrl.latched) {
        resetModifierIfNeeded("ctrl");
      }

      if (metaActive && modifierState.meta.active && !modifierState.meta.latched) {
        resetModifierIfNeeded("meta");
      }

      finalizeCommand();
    });
  </script>
</body>
</html>
